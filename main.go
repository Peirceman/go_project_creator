package main

import (
	"bufio"
	"errors"
	"fmt"
	"io/fs"
	"os"
	"os/exec"
	"strings"
)

var scanner = bufio.NewScanner(os.Stdin)
var colorStdout bool
var colorStderr bool
var dir string
var moduleUrl string
var exeName string

func scanLine(prompt string) string {
	fmt.Print(prompt)
	scanner.Scan()
	return strings.Trim(scanner.Text(), " \t")
}

func setOptions() {
	o, _ := os.Stdout.Stat()
	if (o.Mode() & os.ModeCharDevice) == os.ModeCharDevice {
		colorStdout = true
	} else {
		colorStdout = false
	}

	e, _ := os.Stderr.Stat()
	if (e.Mode() & os.ModeCharDevice) == os.ModeCharDevice {
		colorStderr = true
	} else {
		colorStderr = false
	}
}

func printCmd(cmd *exec.Cmd) {
	printC("{blue}${reset} ")

	for _, arg := range cmd.Args {
		fmt.Print(arg, " ")
	}

	fmt.Println()
}

func main() {
	setOptions()

	makeProjectDir()
	makeModule()
	makeMakefile()
	makeGitRepo()
}

func exists(path string) bool {
	_, err := os.Stat(path)
	return !errors.Is(err, fs.ErrNotExist)
}

func makeMakefile() {
	printlnC("{blue}Info:{reset} creating Makefile")

	if exists("Makefile") {
		contents, err := os.ReadFile("Makefile")
		if err != nil {
			printlnC("{red}Error checking contents of Makefile:", err.Error(), "{reset}")
			return
		}

		if len(contents) > 0 {
			printlnC("{yellow}Warning: Makefile already exists and is not empty{reset}")
			answer := scanLine("Do you want to override it? (Y/N) ")
			if answer[0] != 'Y' && answer[0] != 'y' {
				return
			}
		}
	}

	file, err := os.Create("Makefile")
	if err != nil {
		ePrintlnC("{red}Error creating Makefile:", err.Error(), "{reset}")
		return
	}

	exeName, _ = strings.CutSuffix(scanLine("Executable name: "), ".exe")
	writer := bufio.NewWriter(file)

	writer.WriteString("# generated by go_project_creator: https://github.com/Peirceman/go_project_creator\n\n")
	writer.WriteString("GO_FILES := $(shell find . -name '*.go' ! -name '*_test.go' -type f)\n")
	writer.WriteString("OUTPUT_EXE := ")
	writer.WriteString(exeName)
	writer.WriteString("\n\n")
	writer.WriteString("ifdef OS\n")
	writer.WriteString("	OUTPUT_EXE := $(OUTPUT_EXE).exe\n")
	writer.WriteString("endif\n")
	writer.WriteString("\n")
	writer.WriteString("$(OUTPUT_EXE): $(GO_FILES)\n")
	writer.WriteString("	go build -o $(OUTPUT_EXE)\n")
	writer.Flush()

	file.Close()
}

func runCmd(name string, args ...string) error {

	cmd := exec.Command(name, args...)
	printCmd(cmd)

	cmd.Stdout, cmd.Stderr = os.Stdout, os.Stderr
	err := cmd.Run()

	return err
}

func makeGitRepo() {
	answer := scanLine("Do you want to make a git repository? (Y/N) ")
	if answer[0] == 'N' || answer[0] == 'n' {
		return
	}

	printlnC("{blue}Info:{reset} creating git repository")
	err := runCmd("git", "init")

	if err != nil {
		ePrintlnC("{red}Error creating git repository:", err.Error(), "{reset}")
		return
	}

	makeGitIgnore()
	addGitRemote()
}

func addGitRemote() {
	answer := scanLine("Do you want to add a remote? (Y/N) ")
	if answer[0] != 'Y' && answer[0] != 'y' {
		return
	}

	remoteName := scanLine("Enter remote name: (empty for origin) ")
	if remoteName == "" {
		remoteName = "origin"
	}
	remoteUrl := scanLine("Enter remote url: (empty for " + moduleUrl + ") ")
	if remoteUrl == "" {
		remoteUrl = moduleUrl
	}

	err := runCmd("git", "remote", "add", remoteName, remoteUrl)
	if err != nil {
		ePrintlnC("{red}Error adding remote:", err.Error(), "{reset}")
	}
}

func makeGitIgnore() {
	answer := scanLine("Do you want to add a gitignore? (Y/N) ")
	if answer[0] != 'Y' && answer[0] != 'y' {
		return
	}

	printlnC("{blue}Info:{reset} creating gitignore")

	if exists(".gitignore") {
		contents, err := os.ReadFile(".gitignore")
		if err != nil {
			printlnC("{red}Error checking contents of gitignore:", err.Error(), "{reset}")
			return
		}

		if len(contents) > 0 {
			printlnC("{yellow}Warning: gitignore already exists and is not empty{reset}")
			answer := scanLine("Do you want to override it? (Y/N) ")
			if answer[0] != 'Y' && answer[0] != 'y' {
				return
			}
		}
	}

	file, err := os.Create(".gitignore")
	if err != nil {
		ePrintlnC("{red}Error creating gitignore:", err.Error(), "{reset}")
		return
	}

	writer := bufio.NewWriter(file)
	writer.WriteString("# generated by go_project_creator: https://github.com/Peirceman/go_project_creator\n\n")
	writer.WriteString(exeName)
	writer.WriteString("\n")
	writer.WriteString(exeName)
	writer.WriteString(".exe\n")
	writer.Flush()

	file.Close()
}

func makeModule() {
	printlnC("{blue}Info:{reset} creating module")
	moduleUrl = scanLine("Enter module url: ")

	err := runCmd("go", "mod", "init", moduleUrl)

	if err != nil {
		ePrintlnC("{red}Error creating go module:", err.Error(), "{reset}")
		os.Exit(1)
	}
}

func makeProjectDir() {
	printlnC("{blue}Info:{reset} creating project directory")

	if dir == "" {
		dir = scanLine("Enter project directory: ")
	}

	if exists(dir) {
		contents, err2 := os.ReadDir(dir)
		if len(contents) > 0 {
			printlnC("{yellow}Warning: directory", dir, "already exists and is not empty{reset}")
			answer := scanLine("Do you want to continue? (Y/N) ")

			if answer[0] != 'Y' && answer[0] != 'y' {
				os.Exit(0)
			}
		} else if err2 != nil {
			ePrintlnC("{red}Error checking contents of directory:", err2.Error(), "{reset}")
			os.Exit(1)
		}
	}

	err := os.Mkdir(dir, os.ModeDir)

	if err != nil {
		ePrintlnC("{red}Error creating directory", dir+":", err.(*os.PathError).Err.Error(), "{reset}")
		os.Exit(1)
	}
	os.Chdir(dir)
}
